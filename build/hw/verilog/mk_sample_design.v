//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
// On Mon Sep 19 10:36:18 IST 2022
//
//
// Ports:
// Name                         I/O  size props
// RDY_ma_start                   O     1
// RDY_ma_wait                    O     1
// mav_stop                       O    32 reg
// RDY_mav_stop                   O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_start_inp_config            I    32
// EN_ma_start                    I     1
// EN_ma_wait                     I     1 unused
// EN_mav_stop                    I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mk_sample_design(CLK,
			RST_N,

			ma_start_inp_config,
			EN_ma_start,
			RDY_ma_start,

			EN_ma_wait,
			RDY_ma_wait,

			EN_mav_stop,
			mav_stop,
			RDY_mav_stop);
  input  CLK;
  input  RST_N;

  // action method ma_start
  input  [31 : 0] ma_start_inp_config;
  input  EN_ma_start;
  output RDY_ma_start;

  // action method ma_wait
  input  EN_ma_wait;
  output RDY_ma_wait;

  // actionvalue method mav_stop
  input  EN_mav_stop;
  output [31 : 0] mav_stop;
  output RDY_mav_stop;

  // signals for module outputs
  wire [31 : 0] mav_stop;
  wire RDY_ma_start, RDY_ma_wait, RDY_mav_stop;

  // register rg_data
  reg [31 : 0] rg_data;
  wire [31 : 0] rg_data_D_IN;
  wire rg_data_EN;

  // register rg_state
  reg [1 : 0] rg_state;
  reg [1 : 0] rg_state_D_IN;
  wire rg_state_EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_rl_add_one;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_rg_data_write_1__VAL_1;
  wire MUX_rg_data_write_1__SEL_1, MUX_rg_state_write_1__SEL_1;

  // action method ma_start
  assign RDY_ma_start = rg_state == 2'd0 ;

  // action method ma_wait
  assign RDY_ma_wait = rg_state == 2'd0 || rg_state == 2'd2 ;

  // actionvalue method mav_stop
  assign mav_stop = rg_data ;
  assign RDY_mav_stop = rg_state == 2'd2 ;

  // rule RL_rl_add_one
  assign WILL_FIRE_RL_rl_add_one =
	     rg_state == 2'd1 && rg_data <= 32'hDEADBEEF ;

  // inputs to muxes for submodule ports
  assign MUX_rg_data_write_1__SEL_1 =
	     WILL_FIRE_RL_rl_add_one && rg_data != 32'hDEADBEEF ;
  assign MUX_rg_state_write_1__SEL_1 =
	     WILL_FIRE_RL_rl_add_one && rg_data == 32'hDEADBEEF ;
  assign MUX_rg_data_write_1__VAL_1 = rg_data + 32'd1 ;

  // register rg_data
  assign rg_data_D_IN =
	     MUX_rg_data_write_1__SEL_1 ?
	       MUX_rg_data_write_1__VAL_1 :
	       ma_start_inp_config ;
  assign rg_data_EN =
	     WILL_FIRE_RL_rl_add_one && rg_data != 32'hDEADBEEF ||
	     EN_ma_start ;

  // register rg_state
  always@(MUX_rg_state_write_1__SEL_1 or EN_mav_stop or EN_ma_start)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_rg_state_write_1__SEL_1: rg_state_D_IN = 2'd2;
      EN_mav_stop: rg_state_D_IN = 2'd0;
      EN_ma_start: rg_state_D_IN = 2'd1;
      default: rg_state_D_IN = 2'bxx /* unspecified value */ ;
    endcase
  end
  assign rg_state_EN =
	     WILL_FIRE_RL_rl_add_one && rg_data == 32'hDEADBEEF ||
	     EN_mav_stop ||
	     EN_ma_start ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_data <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (rg_data_EN) rg_data <= `BSV_ASSIGNMENT_DELAY rg_data_D_IN;
	if (rg_state_EN) rg_state <= `BSV_ASSIGNMENT_DELAY rg_state_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_data = 32'hAAAAAAAA;
    rg_state = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_add_one && rg_data != 32'hDEADBEEF)
	$display("sample_design: COMPUTE: rg_data = %h", rg_data + 32'd1);
  end
  // synopsys translate_on
endmodule  // mk_sample_design

